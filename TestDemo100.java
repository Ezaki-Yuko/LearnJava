/**
 * @PackgeName: PACKAGE_NAME
 * @ClassName: TestDemo100
 * @Author: LENOVO
 * Date: 2020/6/2 18:40
 * project name: 20200529
 * @Version:
 * @Description:
 */

/**
 * java web 操作系统,计算机网络基本原理,网络编程 servlet
 * 编写一些服务器程序(搭建一个网站)
 * TCP十个重要特性
 */

/**
 * 冯诺依曼体系结构 => 描述了一台计算机是如何构成的(99%的计算机都是冯诺依曼体系结构)=>硬件的特点会对软件开发造成直接的影响
 *
 * 1.CPU中央处理器 计算机的大脑 Intel
 * 芯片集成程度提高一倍,运算能力提高一倍,成本降低一半
 * CPU集成程度更小,就需要让原件尽量小
 * 2.存储器:存储数据 内存 外存(硬盘 光盘 U盘 软盘)
 * 之前写的代码都是在内存上申请空间
 * IO流是程序和外存打交道
 * 内存外存的对比
 * 1.内存的存储空间较小,外存空间较大
 * 2.内存的访问速度较快(ns级别) 外存访问速度较慢(us) 大概差三四个数量级
 * 3.内存的成本较高,外存的成本较低
 * 4.内存如果断电数据就丢失了 外存支持持久化存储 数据断电不丢失
 *
 * 3.输入设备 键盘 鼠标 摄像头 麦克风...
 * 有些设备既是输入又是输出 触摸屏
 * 4.输出设备 显示器 打印机 音箱
 * 以上都是硬件
 *
 * 操作系统(内核) : 是一个搞管理的软件 一方面是管理计算机硬件设备 管理计算机的软件资源
 * 一个完整的操作系统:内核+配套的应用程序
 * 系统调用接口->操作系统对外提供的编程接口
 * 应用程序上写下代码->代码真正执行println会进入到依赖的库的代码中 本质上需要操作显示器硬件设备限时完成 通过相关的系统调用进入内核中执行代码
 * 这个内核中的代码再执行让显示器输出的动作(内核调用显卡驱动程序,由驱动来具体操作我们的显示器) 每一个硬件都有对应的驱动程序
 *
 * 操作系统的具体管理:
 * 核心工作:
 * 1.描述
 * 2.组织
 *
 * 进程(Process)/任务(Task)
 * 是一种操作系统中非常重要的软件资源 把一个可执行程序跑起来,就得到一个进程 系统中就会创建一个对应的进程 如果这个程序执行结束了 系统就会随之销毁对应的进程
 * 进程就可以看作是一个程序执行的过程
 * 注意区分程序/可执行文件和进程
 * .EXE是静态的,如果不去动就不会发生变化
 * 当双击EXE文件时 操作系统就会加载这个可执行程序
 * 把我们的EXE文件中的很多内容加载到内存中,并且分配一些资源并开始执行这个可执行程序中包含的指令(这就是一个进程)
 * 进程也可以认为是操作系统进行资源分配的最小单位
 * PID 进程ID 进程的身份标识符 两次打开相同的程序进程标识不一定一样
 *
 * 进程管理 本质上 先描述(类)再组织(数据结构)
 * 描述:
 * 以Linux为例 内核中使用一个task_struck/PCB(进程控制块)结构体来描述进程(C语言)
 * 每创建一个进程,就同时创建一个PCB这样的类的实例
 * 组织:
 * 双向链表来组织 把所有PCB对象串到一起
 * 双击一个EXE创建一个进程的时候本质上就是在内核中创建了一个PCB对象,然后把这个对象加入到链表中
 * 结束一个进程的时候,就是在内核中,找到这个对应的PCB对象,然后从链表上删掉,并且释放该对象
 * 通过任务管理器查看到的所有进程信息本质上就是在遍历内核中的这个链表,一次读取对应PCB中的节点信息
 *
 * PCB包含的信息:
 * 1.pid进程id 也就是进程的身份标识
 * 2.内存指针 这就是指向该进程持有的一些重要数据在内存中的位置 重要数据:执行的指令 这些指令依赖的数据有什么 内存就是系统给进程分配的资源的一部分
 * 3.进程的状态
 * 4.进程的优先级
 * 5.进程的记账信息
 * 6.上下文
 * 3-6是为了实现"进程调度" 如果资源非常充裕,那么不需要调度,事实上进程多CPU资源少(CPU同一时刻 一个CPU上只能执行一个程序的指令)
 * 这台机器8核CPU,当前进程已经上百
 * 如何让这么多进程在8个CPU上工作就是依赖进程调度
 * 并发式执行
 * 由于CPU计算/执行指令速度极快,我们就可以让CPU先执行进程1的指令,执行一会儿再执行进程2的指令,再执行一会儿去执行进程3的指令...过了一段时间后继续执行进程1的指令
 * 从微观上来看 这些进程的指令是串行执行的,只不过CPU切换速度极快,人宏观感知不到,这就是并发
 *
 * 并行:宏观同时执行 微观上同时执行(两个CPU同时执行两个进程的执行)
 * 实际工作中不严格区分并行和并发
 * 两个进程在同一个就是并发 两个进程分别在两个CPU就是并行
 *
 * 目的就是为了让这么多进程在有限的CPU上进行并发执行
 *
 * 操作系统中实现进程调度的模块叫做调度器
 * 调度的时候实现有很多策略 这些策略都要依赖PCB中对应的属性
 *
 * 一个进程的状态有:
 * R:就绪状态 正在CPU上执行,或者即将执行
 * S: 睡眠状态 这些进程没法在CPU上执行,而是在等待
 * D:深度睡眠状态:进程长时间忙于IO操作,没精力理会CPU
 * X:退出状态:进程已经被销毁了
 *
 *
 */
public class TestDemo100 {
}
